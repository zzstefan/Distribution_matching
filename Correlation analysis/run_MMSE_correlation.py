import numpy as np
import pandas as pd
import glob
import re
from utils import *
import scipy.stats
from datetime import datetime
import scipy.io as sio
import matplotlib.pyplot as plt
import seaborn as sns
#import patsy
from scipy.stats import wilcoxon
from covbat_revise3 import apply_covbat


#new_data = pd.read_pickle('./data/ADNI_OASIS.pkl')
# read the distribution matching harmonized results
new_data = pd.read_csv('/autofs/space/genesis_001/users/Projects/PPMI/code/matlab_code/DM_OASISADNI/base_OASISADNI.csv')
new_data['DM_C'] = [i.split('connMat_Hough.mat')[0] + 'baseline_ADNIOASIS/DM_C.mat' for i in
                                 list(new_data['conn_mat'].values)]
new_data['DM_aC'] = [i.split('connMat_Hough.mat')[0] + 'baseline_ADNIOASIS/DM_aC.mat' for i in
                                 list(new_data['conn_mat'].values)]
C = read_sc(new_data, 'C')  # without log transformation
aC = read_sc(new_data,'aC') # without log transformation


DM_C = np.zeros((len(new_data), int(85 * 84 / 2)))
DM_aC = np.zeros((len(new_data), int(85 * 84 / 2)))
for i in range(len(new_data)):
    tmp = scipy.io.loadmat(new_data.loc[i, 'DM_aC'])['DM_aC']
    DM_aC[i, :] = tmp[np.triu_indices(85, k=1)]
    tmp2 = scipy.io.loadmat(new_data.loc[i, 'DM_C'])['DM_C']
    DM_C[i, :] = tmp2[np.triu_indices(85, k=1)]


#Read the harmonized results generated by the distribution matching method in different gender goups
#we used DM_C_SG and DM_aC_SG to represent the harmonized results generated by male and female sex groups;
new_dir = '/autofs/space/genesis_001/users/Projects/PPMI/code/matlab_code/DM_OASISADNI/harmonized_matrices_sex'
sex_mapping = {'F': 'female', 'M': 'male'}

# Create the 'DM_C_SG' column with full file paths, converting F/M to female/male
new_data['DM_C_SG'] = [new_dir + '/'+ sub_id + '_' + sex_mapping[sex] + '_DM_C.mat' 
                       for sub_id, sex in zip(new_data['Subject_ID'], new_data['Sex'])]
new_data['DM_aC_SG'] = [new_dir + '/'+ sub_id + '_' + sex_mapping[sex] + '_DM_aC.mat' 
                       for sub_id, sex in zip(new_data['Subject_ID'], new_data['Sex'])]
C = read_sc(new_data, 'C')  # without log transformation
aC = read_sc(new_data,'aC') # without log transformation

DM_C_SG = np.zeros((len(new_data), int(85 * 84 / 2)))
DM_aC_SG = np.zeros((len(new_data), int(85 * 84 / 2)))
for i in range(len(new_data)):
    tmp = scipy.io.loadmat(new_data.loc[i, 'DM_aC_SG'])['DM_aC']
    DM_aC_SG[i, :] = tmp[np.triu_indices(85, k=1)]
    tmp2 = scipy.io.loadmat(new_data.loc[i, 'DM_C_SG'])['DM_C']
    DM_C_SG[i, :] = tmp2[np.triu_indices(85, k=1)]



nonZero_col = np.where(C.any(axis=0))[0]
zero_col = np.where(~C.any(axis=0))[0]
sc= np.delete(C, zero_col, axis=1)
sc2 = np.log(sc+1)


# Combat harmonization without age as input, on log space
model, combat_noAge_C = harmonize_noAge(sc2, new_data)
com_noAge_C = recon_full(combat_noAge_C, new_data, nonZero_col)
# new_temp = np.zeros((len(new_data), 3570))
# new_temp[:, nonZero_col] = combat_noAge_C
# com_noAge_C = new_temp

# Combat harmonization without age or sex as input, on log space
model, combat_noAge_noSex_C = harmonize_noAge_noSex(sc2, new_data)
com_noAge_noSex_C = recon_full(combat_noAge_noSex_C, new_data, nonZero_col)

# Combat harmonization without age as input on aC, on log space
model, com_noAge_aC = harmonize_noAge(np.log(aC+1), new_data)

# Combat harmonization without age or sex as input on aC, on log space
model, com_noAge_noSex_aC = harmonize_noAge_noSex(np.log(aC+1), new_data)


# for covbat, DM_C:
batch = new_data['SITE']
sex = new_data['Sex'].values

cov_noAge_C_tmp = apply_covbat(sc2, batch, sex=sex)
cov_noAge_C = recon_full(cov_noAge_C_tmp, new_data, nonZero_col)

cov_noAge_noSex_C_tmp = apply_covbat(sc2, batch)
cov_noAge_noSex_C = recon_full(cov_noAge_noSex_C_tmp, new_data, nonZero_col)


cov_noAge_aC = apply_covbat(np.log(aC+1),batch,sex=sex)
cov_noAge_noSex_aC = apply_covbat(np.log(aC+1), batch)



SC = {'C': norm_fea(C), 'DM_C': norm_fea(DM_C), 'DM_C_SG': norm_fea(DM_C_SG), 
      'Com_noAge_C': norm_fea(np.exp(com_noAge_C)-1), 
      'Com_noAge_noSex_C': norm_fea(np.exp(com_noAge_noSex_C)-1),
      'Cov_noAge_C': norm_fea(np.exp(cov_noAge_C)-1),
      'Cov_noAge_noSex_C': norm_fea(np.exp(cov_noAge_noSex_C)-1),
      'aC': norm_fea(aC), 'DM_aC': norm_fea(DM_aC), 'DM_aC_SG': norm_fea(DM_aC_SG), 
      'Com_noAge_aC': norm_fea(np.exp(com_noAge_aC)-1),
      'Com_noAge_noSex_aC': norm_fea(np.exp(com_noAge_noSex_aC)-1),
      'Cov_noAge_aC': norm_fea(np.exp(cov_noAge_aC)-1),
      'Cov_noAge_noSex_aC': norm_fea(np.exp(cov_noAge_noSex_aC)-1)}


MMSE_index = new_data.loc[~new_data.MMSE.isna()].index
MMSE_new = new_data.loc[MMSE_index, 'MMSE'].values
age = new_data.Age.values

column_name = [i+'_MMSE' for i in list(SC.keys())]

r = np.zeros((aC.shape[1],len(SC)))
p = np.zeros((aC.shape[1],len(SC)))

for j,c in enumerate(list(SC.keys())):
    fea = SC[c][MMSE_index, :]
    for i in range(aC.shape[1]):
        r[i, j], p[i, j] = scipy.stats.pearsonr(MMSE_new, fea[:, i])


p = p*3570
df_corr = pd.DataFrame(data=p, columns=column_name)
df_corr.to_pickle('/autofs/space/genesis_001/users/Projects/PPMI/code/Result_Figure_revision/p_OASISADNI_MMSE.pkl')
np.save('/autofs/space/genesis_001/users/Projects/PPMI/code/Result_Figure_revision/r_OASISADNI_MMSE.npy', r)

R = np.abs(r)
mean_r= np.nanmean(R, axis=0)
std_r = np.nanstd(R, axis=0)
#1.  Mean and std of absolute correlations
print("\n=== Mean and Std of Absolute Correlations (|r|) ===")
print("Format: Mean (Std)")
for i, key in enumerate(SC.keys()):
    print(f"{key}: {mean_r[i]:.2f} ({std_r[i]:.2f})")

#2. Wilcoxon tests with scientific notation p-values
print("\n=== Wilcoxon Signed-Rank Tests (Greater Alternative) ===")
print("Comparing absolute correlations (|r|) between feature sets")
for i in [0, 7]:  # Indices for 'C' and 'aC'
    base_name = list(SC.keys())[i]
    print(f"\nBase: {base_name}")
    for j in range(i + 1, i + 7):  # Compare to next 6 features
        comp_name = list(SC.keys())[j]
        res = wilcoxon(R[:, j], R[:, i], alternative='greater', nan_policy='omit')
        print(f"{comp_name} vs {base_name}: statistic={res.statistic:.2f}, p-value={res.pvalue:.0e}")

#3. Significant p-values count
sig_counts = (df_corr < 0.05).sum()
print("\n=== Number of Significant Correlations (p < 0.05) ===")
for col, count in sig_counts.items():
    print(f"{col}: {count}")

#4. Minimum p-values in scientific notation
min_p = df_corr.min(axis=0).apply(lambda x: f"{x:.0e}")
print("\n=== Minimum Bonferroni-Corrected p-values ===")
for col, pval in min_p.items():
    print(f"{col}: {pval}")



# np.save('/autofs/space/genesis_001/users/Projects/PPMI/code/Result_Figure/r_OASISADNI.npy', r)
# np.save('/autofs/space/genesis_001/users/Projects/PPMI/code/Result_Figure/ab_r_OASISADNI.npy', R)

# from scipy.stats import wilcoxon
# for i in [0,7]:
#     for j in range(i+1,i+7):
#         res = wilcoxon(R[:,j], R[:,i], alternative='greater',nan_policy='omit')
#         print(res)

# print((df_corr < 0.05).sum())
# print(df_corr.min(axis=0).apply(lambda x: f"{x:.0e}"))

# for i in range(len(SC)):
#     round_mean = "{:.2f}".format(mean_r[i])
#     round_std = "{:.2f}".format(std_r[i])
#     print( f'{round_mean} ({round_std})') 


##### correlation between C/aC and MMSE within ADNI-2 or OASIS-3 (before harmonization, individually)
## for OASIS-3

#OASIS_id = new_data.loc[new_data['SITE']=='OASIS-3'].index.tolist()
# c='C' # 'aC' or 'C'
# dataset = 'ADNI2' # 'ADNI2' or 'OASIS-3'

for c in ['C', 'aC']:
    for dataset in ['OASIS-3', 'ADNI2']:
        r = np.zeros(aC.shape[1])
        p = np.zeros(aC.shape[1])
        MMSE_index = new_data.loc[(~new_data.MMSE.isna()) & (new_data['SITE']==dataset)].index
        MMSE_OASIS = new_data.loc[MMSE_index,'MMSE'].values
        fea = SC[c][MMSE_index, :]
        for i in range(fea.shape[1]):
            r[i], p[i] = scipy.stats.pearsonr(MMSE_OASIS, fea[:, i])

        R = np.abs(r)
        mean_r= np.nanmean(R, axis=0)
        std_r = np.nanstd(R, axis=0)
        round_mean = "{:.2f}".format(mean_r)
        round_std = "{:.2f}".format(std_r)
        print('%s with %s in MMSE'%(c, dataset))
        print( f'{round_mean} ({round_std})') 


        p = p*3570
        print("{:.0e}".format(np.nanmin(p)))
        print((p < 0.05).sum())


##### correlation between C/aC and age within ADNI-2 or OASIS-3 (before harmonization, individually)
## for OASIS-3

#OASIS_id = new_data.loc[new_data['SITE']=='OASIS-3'].index.tolist()
# c='C' # 'aC' or 'C'
# dataset = 'OASIS-3' # 'ADNI2' or 'OASIS-3'

for c in ['C', 'aC']:
    for dataset in ['OASIS-3', 'ADNI2']:
        r = np.zeros(aC.shape[1])
        p = np.zeros(aC.shape[1])
        age_index = new_data.loc[(~new_data.Age.isna()) & (new_data['SITE']==dataset)].index
        age = new_data.loc[age_index,'Age'].values
        fea = SC[c][age_index, :]
        for i in range(fea.shape[1]):
            r[i], p[i] = scipy.stats.pearsonr(age, fea[:, i])

        R = np.abs(r)
        mean_r= np.nanmean(R, axis=0)
        std_r = np.nanstd(R, axis=0)
        round_mean = "{:.2f}".format(mean_r)
        round_std = "{:.2f}".format(std_r)
        print('%s with %s in age'%(c, dataset))
        print( f'{round_mean} ({round_std})') 


        p = p*3570
        print("{:.0e}".format(np.nanmin(p)))
        print((p < 0.05).sum())

